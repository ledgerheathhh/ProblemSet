// 935. 骑士拨号器
// 中等
// 象棋骑士有一个独特的移动方式，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个 L 的形状)。
// 象棋骑士可能的移动方式如下图所示:

// 我们有一个象棋骑士和一个电话垫，如下所示，骑士只能站在一个数字单元格上(即蓝色单元格)。

// 给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。

// 你可以将骑士放置在任何数字单元格上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是有效的骑士跳跃。

// 因为答案可能很大，所以输出答案模 109 + 7.

 

// 示例 1：
// 输入：n = 1
// 输出：10
// 解释：我们需要拨一个长度为1的数字，所以把骑士放在10个单元格中的任何一个数字单元格上都能满足条件。

// 示例 2：
// 输入：n = 2
// 输出：20
// 解释：我们可以拨打的所有有效号码为[04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]

// 示例 3：
// 输入：n = 3131
// 输出：136006598
// 解释：注意取模
 

// 提示：

// 1 <= n <= 5000



// 方法一：动态规划

// 我们用 d[n][x] 表示在数字单元格 x 上执行 n−1 次跳跃后可得到的不同的长度为 n 的号码数量，
// 别紧张，我们只是暂时用它来描述要解决的问题。现在我们要从 x 出发，遵循骑士的移动方式来跳跃到其他的数字上，
// 例如 y，而此时问题将变为求解 d[n−1][y]。
// 因此，我们只要找到对于 x 来说所有合法的 y，就可以将一个需要移动 n−1 次来解决的问题缩减为几个需要移动 n−2 次来解决的问题。
// 值得庆幸的是，题目给定的电话垫很小，总共不过 10 个合法的位置，只需预处理出每个 x 的 y 集合即可。
// 这样我们就不用在每个位置上一一枚举 8 个方向进行移动了。
// 综上，我们得到递推方程：

// d[n][x]=∑ y∈Sx d[n][y]

// 其中 Sx 是位置 x 的合法移动集合，例如 x=0 时，S0={4,6}, x=4 时，S4 ={3,9,0}。

// 最初，所有的 d[1][x] 都初始化为 1，最终答案是所有 d[n][x] 的和。
// 一般情况下，我们需要一个形状为 n×10 的二维数组来存放所有问题的解，
// 但注意到第 n 维度的问题只需要借助第 n−1 维度的答案来求解，
// 因此可以压缩为 2×10 的二维数组，然后通过循环、滚动的方式不断重复利用另一层为空的数组（大小为 10），进而降低空间利用率。

function knightDialer(n: number): number {
  const mod = 1_000_000_007;
  const moves: number[][] = [
      [4, 6],
      [6, 8],
      [7, 9],
      [4, 8],
      [3, 9, 0],
      [],
      [1, 7, 0],
      [2, 6],
      [1, 3],
      [2, 4],
  ];
  const d = Array.from({ length: 2 }, () => Array(10).fill(0));
  d[1].fill(1);

  for (let i = 2; i <= n; i++) {
      const x = i & 1;
      for (let j = 0; j < 10; j++) {
          d[x][j] = 0;
          for (const k of moves[j]) {
              d[x][j] = (d[x][j] + d[x ^ 1][k]) % mod;
          }
      }
  }
  return d[n % 2].reduce((res, x) => (res + x) % mod, 0);
};