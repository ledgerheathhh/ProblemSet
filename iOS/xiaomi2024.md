# 【2024】小米秋招笔试-IOS-卷2

## 单选题

1. 以下为 Linux 下的 32 位 C 程序
char str[] = "Hello";
char *p = str;
其中 sizeof(p)的结果为：
- A. 1
- B. 4
- C. 8
- D. 2

正确答案: B
*   **解析:** 在32位系统中，指针的大小是4字节。`p` 是一个字符指针，它存储的是 `str` 数组的首地址。`sizeof(p)` 计算的是指针变量 `p` 本身所占用的内存大小，而不是它所指向的内存大小。因此，在32位系统下，`sizeof(p)` 的结果是4。
---


2. TCP 处于 OSI 哪一层：
- A. 表示层
- B. 传输层
- C. 应用层
- D. 会话层

正确答案: B
*   **解析:** TCP（传输控制协议）是传输层的协议，它提供可靠的、面向连接的数据传输服务。OSI（开放系统互连）模型将网络通信分为七层，传输层是第四层。
---


3. 以下关于面向对象的描述错误的是：
- A. 面向对象的基本特性是封装，继承和多态
- B. 多态的必要条件是要有继承，要有方法的重写，父类引用指向子类对象
- C. 多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式
- D. 子类重新定义父类虚函数的方法叫做重载

正确答案: D
*   **解析:**
    *   A. 面向对象的基本特性是封装、继承和多态，这是正确的。
    *   B. 多态的必要条件确实包括继承、方法的重写以及父类引用指向子类对象，这是正确的。
    *   C. 多态的定义是允许不同类的对象对同一消息做出响应，即同一消息可以根据发送对象的不同而采用多种不同的行为方式，这是正确的。
    *   D. 子类重新定义父类虚函数的方法叫做**重写（Override）**，而不是重载（Overload）。重载是指在同一个作用域内，函数名相同但参数列表不同的函数。因此，D选项是错误的。
---


4. 关于进程和线程的描述正确的是：
- A. 线程切换消耗比进程切换消耗要大
- B. 进程是操作系统能够进行运算调度的最小单位
- C. 线程是资源分配的最小单位
- D. 一个进程中可以包含多个线程

正确答案: D
*   **解析:**
    *   A. 线程切换消耗通常比进程切换消耗要小，因为线程共享进程的地址空间，切换时上下文保存和恢复的内容较少。因此A错误。
    *   B. 进程是操作系统进行资源分配的最小单位，线程是操作系统能够进行运算调度的最小单位。因此B错误。
    *   C. 线程是CPU调度和分派的基本单位，是程序执行的最小单位，而进程是资源分配的最小单位。因此C错误。
    *   D. 一个进程中可以包含多个线程，这些线程共享进程的资源，这是正确的。
---


5. 关于 UDP 的描述正确的是：
- A. 一种可靠的面向连接的协议
- B. 一种不可靠的面向连接的协议
- C. 一种可靠的无连接协议
- D. 一种不可靠的无连接协议

正确答案: D
*   **解析:** UDP（用户数据报协议）是一种无连接的协议，它不提供可靠的数据传输服务，不保证数据包的顺序、不进行重传、不进行流量控制和拥塞控制。因此，它是一种不可靠的无连接协议。
---


6. 以下代码执行结果是什么？
```objective-c
(void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"1");
    dispatch_sync(dispatch_get_main_queue(),^{
        NSLog(@"2");
    });
    NSLog(@"3");
}
```

- A. 1 2 3
- B. 1 3 2
- C. 1 3
- D. 1

正确答案: D
*   **解析:**
    1.  `NSLog(@"1");` 会首先打印 "1"。
    2.  `dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@"2"); });` 尝试在主队列上同步执行一个任务。
    3.  `viewDidLoad` 方法本身就是在主线程（主队列）上执行的。
    4.  当在主线程上同步向主队列添加任务时，会发生死锁。因为主线程正在等待 `dispatch_sync` 中的任务完成，而 `dispatch_sync` 中的任务又需要主线程来执行。这导致主线程被阻塞，任务无法执行，从而造成死锁。
    5.  因此，`NSLog(@"2");` 和 `NSLog(@"3");` 都不会被执行到。
---


7. Objective-C 中关于类方法和实例方法描述错误的是
- A. 类方法中的 self 是类对象
- B. 类方法可以调用其他的类方法
- C. 实例方法中的 self 是实例对象
- D. 类方法可以直接调用实例方法

正确答案: D
*   **解析:**
    *   A. 类方法中的 `self` 是类对象，这是正确的。
    *   B. 类方法可以调用其他的类方法，这是正确的。
    *   C. 实例方法中的 `self` 是实例对象，这是正确的。
    *   D. 类方法不能直接调用实例方法。实例方法需要通过实例对象来调用，而类方法没有实例对象。如果类方法需要调用实例方法，它必须先创建一个实例对象。因此，D选项是错误的。
---


8. Objective-C 中属性采用@property (nonatomic, copy) NSMutableArray *mutableArray
修饰，调用[self.mutableArray addObject:@"object"]编译或运行的结果是
- A. 编译不通过
- B. 可以正常运行，并添加@"object"
- C. 可以正常运行，但是不能添加@"object"
- D. 可以编译通过，但是运行崩溃

正确答案: D
*   **解析:**
    *   `copy` 修饰符会创建一个对象的副本。对于可变对象（如 `NSMutableArray`），`copy` 会创建一个不可变副本（`NSArray`）。
    *   当 `mutableArray` 被 `copy` 修饰时，`self.mutableArray` 返回的是一个 `NSArray` 类型的对象（尽管声明为 `NSMutableArray *`）。
    *   `NSArray` 是不可变的，因此调用 `addObject:` 方法会导致运行时崩溃，因为不可变数组不支持添加元素的操作。
    *   编译时不会报错，因为类型声明是 `NSMutableArray *`，编译器认为可以调用 `addObject:` 方法。
---


9. 关于二叉搜索树(二叉排序树)描述错误的是:
- A. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
- B. 对二叉搜索树(二叉排序树)进行中序遍历，一定会得到节点关键字的有序序列
- C. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
- D. 二叉搜索树(二叉排序树)中节点个数相同时，完全二叉树的查找效率最低

正确答案: D
*   **解析:**
    *   A. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值，这是二叉搜索树的定义之一，正确。
    *   B. 对二叉搜索树进行中序遍历，一定会得到节点关键字的有序序列，这是二叉搜索树的重要特性，正确。
    *   C. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值，这是二叉搜索树的定义之一，正确。
    *   D. 二叉搜索树中节点个数相同时，查找效率最低的情况是退化成链表（例如，插入的元素总是递增或递减），而不是完全二叉树。完全二叉树的查找效率是比较高的（接近平衡二叉树）。因此，D选项是错误的。
---


10. 一颗二叉树，头序序列为 ABCDEFG ，中序序列为 CBDAEGF ，则其后序序列为 ( )
- A. CDBGFEA
- B. CDBFGEA
- C. CDBAGFE
- D. BCDAGFE

正确答案: A
*   **解析:**
    *   **前序遍历 (Preorder):** 根 -> 左 -> 右 (ABCDEFG)
    *   **中序遍历 (Inorder):** 左 -> 根 -> 右 (CBDAEGF)

    1.  从前序遍历 `ABCDEFG` 可知，根节点是 `A`。
    2.  在中序遍历 `CBDAEGF` 中找到 `A`，`A` 左边的 `CBD` 是左子树的中序遍历，`EGF` 是右子树的中序遍历。
    3.  根据左子树的中序遍历 `CBD` 和前序遍历中对应的部分 `BCD` (从 `A` 后面开始，直到右子树的第一个元素 `E` 之前)，可知左子树的根是 `B`。
    4.  在中序遍历 `CBD` 中找到 `B`，`C` 是 `B` 的左子树，`D` 是 `B` 的右子树。
    5.  根据右子树的中序遍历 `EGF` 和前序遍历中对应的部分 `EFG` (从 `A` 后面 `B` 之后的部分)，可知右子树的根是 `E`。
    6.  在中序遍历 `EGF` 中找到 `E`，`G` 是 `E` 的右子树，`F` 是 `G` 的左子树（这里需要注意，`F` 在 `G` 之前，但 `G` 是 `E` 的右子树的根，所以 `F` 应该是 `G` 的左子树）。
    7.  构建出二叉树结构后，进行后序遍历（左 -> 右 -> 根）：
        *   左子树：`C` -> `D` -> `B`
        *   右子树：`F` -> `G` -> `E`
        *   根：`A`
        *   所以后序遍历为：`CDBGFEA`
---


## 多选题

11. 以下哪些是 HTTP 协议包含的请求
*   **解析:**
    *   **前序遍历 (Preorder):** 根 -> 左 -> 右 (ABCDEFG)
    *   **中序遍历 (Inorder):** 左 -> 根 -> 右 (CBDAEGF)

    1.  从前序遍历 `ABCDEFG` 可知，根节点是 `A`。
    2.  在中序遍历 `CBDAEGF` 中找到 `A`，`A` 左边的 `CBD` 是左子树的中序遍历，`EGF` 是右子树的中序遍历。
    3.  根据左子树的中序遍历 `CBD` 和前序遍历中对应的部分 `BCD` (从 `A` 后面开始，直到右子树的第一个元素 `E` 之前)，可知左子树的根是 `B`。
    4.  在中序遍历 `CBD` 中找到 `B`，`C` 是 `B` 的左子树，`D` 是 `B` 的右子树。
    5.  根据右子树的中序遍历 `EGF` 和前序遍历中对应的部分 `EFG` (从 `A` 后面 `B` 之后的部分)，可知右子树的根是 `E`。
    6.  在中序遍历 `EGF` 中找到 `E`，`G` 是 `E` 的右子树，`F` 是 `G` 的左子树（这里需要注意，`F` 在 `G` 之前，但 `G` 是 `E` 的右子树的根，所以 `F` 应该是 `G` 的左子树）。
    7.  构建出二叉树结构后，进行后序遍历（左 -> 右 -> 根）：
        *   左子树：`C` -> `D` -> `B`
        *   右子树：`F` -> `G` -> `E`
        *   根：`A`
        *   所以后序遍历为：`CDBGFEA`



1.  以下哪些是 HTTP 协议包含的请求
- A. GET
- B. HEAD
- C. PUT
- D. DELETE

正确答案: ABCD
*   **解析:** HTTP协议定义了多种请求方法（也称为动词），用于指示对给定资源执行的期望动作。常见的HTTP请求方法包括：`GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`。题目中给出的 `GET`, `HEAD`, `PUT`, `DELETE` 都是HTTP协议包含的请求方法。
---


12. 关于链表和数组以下描述正确的是：
- A. 链表不需要指定占用空间大小
- B. 链表删除和插入相对便捷
- C. 数组需要申请连续的内存空间
- D. 数组访问效率比较高

正确答案: BCD
*   **解析:**
    *   A. 链表不需要指定占用空间大小，它通过指针动态分配内存，可以根据需要增长或缩小。数组在创建时通常需要指定大小（静态数组）或在运行时动态调整大小（动态数组），但其内存是连续的。因此A错误。
    *   B. 链表删除和插入相对便捷。在链表中，插入和删除元素只需要修改相邻节点的指针，时间复杂度为O(1)（如果已知插入/删除位置）。数组在插入和删除元素时，可能需要移动大量元素，时间复杂度为O(n)。因此B正确。
    *   C. 数组需要申请连续的内存空间。这是数组的特点，使得可以通过索引直接访问元素。因此C正确。
    *   D. 数组访问效率比较高。由于数组的内存是连续的，可以通过索引直接计算出元素的内存地址，实现O(1)的随机访问。链表需要从头节点开始遍历才能找到指定位置的元素，访问效率较低（O(n)）。因此D正确。
---


13. 以下属于 Objective-C 中属性修饰符的有哪些：
- A. nonatomic
- B. strong
- C. weak
- D. copy

正确答案: ABCD
*   **解析:** Objective-C中常用的属性修饰符包括：`atomic` (默认), `nonatomic` (原子性); `readwrite` (默认), `readonly` (读写权限); `assign`, `strong`, `weak`, `copy` (内存管理); `getter=<name>`, `setter=<name>` (方法名)。题目中给出的 `nonatomic`, `strong`, `weak`, `copy` 都是Objective-C中常用的属性修饰符。
---


14. 以下属于设计模式原则的是：
- A. "开-闭"原则
- B. 里氏代换原则
- C. 单一职能原则
- D. 依赖倒转原则

正确答案: ABCD
*   **解析:** 软件设计模式的六大原则包括：单一职责原则 (SRP), 开闭原则 (OCP), 里氏替换原则 (LSP), 依赖倒置原则 (DIP), 接口隔离原则 (ISP), 迪米特法则 (LoD)。题目中给出的 "开-闭"原则, 里氏代换原则, 单一职能原则, 依赖倒转原则都属于设计模式原则。
---


15. MySQL 中关于 replace into 和 insert into 描述正确的有哪些：
- A. insert into 可能会插入失败
- B. replace into 会有删除数据的操作,所以我们必须对表有删除权限
- C. 插入数据的表没有主键或者是唯一索引时，replace into 会直接插入数据
- D. 插入数据的表主键或者索引重复，replace into 会执行失败

正确答案: ABC
*   **解析:**
    *   A. `INSERT INTO` 可能会插入失败。例如，如果插入的数据违反了唯一约束（如主键或唯一索引），或者存在非空字段没有提供值，`INSERT INTO` 操作会失败。因此A正确。
    *   B. `REPLACE INTO` 的行为是：如果插入的行在表中存在主键或唯一索引冲突，则先删除旧行，然后插入新行。这意味着它会执行删除操作，因此需要对表有删除权限。因此B正确。
    *   C. 插入数据的表没有主键或者是唯一索引时，`REPLACE INTO` 会直接插入数据，因为它找不到冲突的行来替换，所以它会像 `INSERT INTO` 一样执行插入操作。因此C正确。
    *   D. 插入数据的表主键或者索引重复时，`REPLACE INTO` 会执行替换操作（删除旧行，插入新行），而不是执行失败。因此D错误。
---


## 问答题

16. 【合并两个有序链表】

问题描述:
例如链表A:1->3->5和链表B:2->4->6，输出为1->2->3->4->5->6
```java
/**
 * 节点类
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    }
}
```

输入描述:
两行逗号分隔的数字，分别表示两个链表。

输出描述:
输出逗号分隔的一行数字，为合并后的有序链表。

输入样例:
1,3,5 2,4,6

输出样例:
1,2,3,4,5,6

*   **解题思路:**
    *   **迭代法：** 创建一个哑节点（dummy node）作为新链表的头，然后使用一个指针 `temp` 遍历两个链表。比较 `l1` 和 `l2` 当前节点的值，将较小值的节点连接到 `temp` 的 `next`，然后移动 `temp` 和被连接的链表的指针。当其中一个链表遍历完后，将另一个链表剩余的部分直接连接到新链表的末尾。
    *   **递归法：** 如果 `l1` 为空，返回 `l2`；如果 `l2` 为空，返回 `l1`。如果 `l1.val <= l2.val`，则 `l1` 的 `next` 指向 `mergeTwoLists(l1.next, l2)` 的结果，并返回 `l1`。否则，`l2` 的 `next` 指向 `mergeTwoLists(l1, l2.next)` 的结果，并返回 `l2`。

*   **参考代码（Java）：**
    ```java
    /**
     * 节点类
     * public class ListNode {
     *     int val;
     *     ListNode next;
     *     ListNode() {}
     *     ListNode(int val) { this.val = val; }
     *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
     * }
     */
    class Solution {
        public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
            if (l1 == null) return l2;
            if (l2 == null) return l1;
            ListNode head = new ListNode(0); // 哑节点
            ListNode temp = head;
            while(l1 != null && l2 != null) {
                if (l1.val <= l2.val) {
                    temp.next = l1;
                    l1 = l1.next;
                } else {
                    temp.next = l2;
                    l2 = l2.next;
                }
                temp = temp.next;
            }
            // 连接剩余部分
            if (l1 == null) {
                temp.next = l2;
            } else {
                temp.next = l1;
            }
            return head.next; // 返回实际头节点
        }
    }

    // 为了完整性，这里也提供ListNode的定义，实际提交时可能已提供
    class ListNode {
        int val;
        ListNode next;
        ListNode() {}
        ListNode(int val) { this.val = val; }
        ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    }
    ```
---

17. 【给出一个字符串s（仅含有小写英文字母和括号）】

问题描述:
给出一个字符串s（仅含有小写英文字母和括号）。
请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。
注意，您的结果中不应包含任何括号。
例如
输入 s = "(abcd)",输出："dcba"
输入：s = "(a(bc)d)",输出："dbca"

输入描述:
输入一行，一个字符串

输出描述:
输出一行，最终匹配的字符串结果

输入样例:
(abcd)

输出样例:
dcba

*   **解题思路:**
    *   这道题可以使用栈（Stack）来解决。
    *   遍历字符串：
        *   当遇到 `(` 时，将当前已经处理好的字符串压入栈中，并清空当前字符串，准备处理括号内的内容。
        *   当遇到 `)` 时，说明一个括号对结束。将当前字符串反转，然后从栈中弹出上一个字符串，将反转后的当前字符串追加到弹出的字符串后面。
        *   当遇到小写英文字母时，将其追加到当前字符串。
    *   最终栈中应该只剩下一个元素（或者当前字符串就是最终结果），即为反转后的字符串。

*   **参考代码（JavaScript）：**
```javascript
var reverseParentheses = function(s) {
        const stk = []; // 栈用于存储括号外的字符串
        let str = '';   // 当前正在处理的字符串
        for (const ch of s) {
            if (ch === '(') {
                stk.push(str); // 将当前str压入栈中
                str = '';      // 重置str，准备处理括号内的内容
            } else if (ch === ')') {
                str = str.split("").reverse().join(""); // 反转括号内的内容
                str = stk[stk.length - 1] + str; // 与栈顶元素拼接
                stk.pop(); // 弹出栈顶元素
            } else {
                str += ch; // 普通字符直接追加
            }
        }
        return str; // 返回最终结果
    };

    // 以下是牛客网在线编程环境的输入输出方式，实际提交时可能需要根据平台调整
    // var line = read_line()
    // print(reverseParentheses(line))
```
