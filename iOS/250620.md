## 1. 下面关于集合说法错误的是:

A. OC语言的所有集合都是对象, 集合中的元素也都是对象，集合中也只能存放对象。

B. 集合中不能存放nil空对象，nil是作为集合结束标识符。

C. 简单及复杂数据类型（int、double、CGPoint、CGRect）可以封装为NSValue、NSNumber对象再放入集合类中；

D. OC语言的集合仅包含数组和字典。

**正确答案：D**

### 官方解析：

D选项错误,因为OC语言的集合类型不仅包含数组(NSArray)和字典(NSDictionary),还包括:
*   NSSet(集合)
*   NSOrderedSet(有序集合)
*   NSHashTable
*   NSMapTable 等多种集合类型

分析其他选项:

A选项正确:在OC中,集合确实都是对象(NSArray、NSDictionary等),并且集合中只能存储对象类型,不能直接存储基本数据类型。

B选项正确:nil在OC中是作为集合的结束标识符,集合中不能存储nil对象。如果需要表示空,可以使用NSNull对象。

C选项正确:对于基本数据类型(int、double等)和结构体类型(CGPoint、CGRect等),需要先将其封装成NSNumber或NSValue对象,才能存入集合中。这是因为OC的集合只能存储对象。

**知识延伸:** OC的集合类型丰富,每种集合都有其特定的使用场景。了解这些集合类型的特点和适用场景,对于开发高效的OC程序很重要。


---
## 2. 在Objective-C中，关于Block描述错误的是（）

A. 使用^符号声明Block：在Block的开始位置使用^符号，后面跟着参数列表和代码块

B. 使用typedef定义Block类型

C. Block的语法类似于匿名函数或闭包，它由一对小括号()包围，可以接受参数并返回值

D. Block在Objective-C中广泛应用于异步编程、回调函数、遍历集合等场景

**正确答案：C**

### 官方解析：

C选项错误。Block的语法类似于匿名函数或闭包，它由一对花括号`{}`包围，而不是小括号`()`。小括号`()`通常用于参数列表。

分析其他选项:

A选项正确: 在Block的开始位置使用`^`符号是声明Block的正确方式。

B选项正确: 可以使用`typedef`关键字来定义Block类型，这有助于提高代码的可读性和复用性。

D选项正确: Block在Objective-C中确实广泛应用于异步编程、回调函数、遍历集合以及动画等多种场景，是实现高阶函数和闭包的重要特性。

---
## 3. 下列NSArray初始化不正确的是

A. NSArray *array = [NSArray arrayWithObjects:@"a", @"b", @"c", nil];

B. NSArray *array = [[NSArray alloc] initWithObjects:@"a", @"b", @"c", nil];

C. NSArray *array = @[@"a", @"b", @"c", nil];

D. NSArray *array = @[@"a", @"b", @"c"];

这道题目考察了NSArray的初始化方法。

### 分析所有选项:

A. `NSArray *array = [NSArray arrayWithObjects:@"a", @"b", @"c", nil];`
   **正确**：这是传统的初始化方法，`nil`作为参数列表的结束标志。

B. `NSArray *array = [[NSArray alloc] initWithObjects:@"a", @"b", @"c", nil];`
   **正确**：这也是传统的初始化方法，`nil`作为参数列表的结束标志。

C. `NSArray *array = @[@"a", @"b", @"c", nil];`
   **不正确**：在使用Objective-C字面量语法`@[]`创建数组时，不能包含`nil`。`nil`会被视为数组的结束符，导致`nil`及其后面的元素不会被添加到数组中，这可能导致运行时错误或意外行为。

D. `NSArray *array = @[@"a", @"b", @"c"];`
   **正确**：这是现代Objective-C字面量语法创建数组的正确方式，简洁且推荐使用。

**正确答案：C**

**补充说明:** 在使用字面量语法时，如果需要表示空值，应该使用`NSNull`对象，而不是`nil`。字面量语法是在LLVM 4.0编译器引入的现代Objective-C特性，提供了更简洁的数组创建方式。

---
## 4. 以下关于UIKit说法错误的是：

A. UIView继承自NSObect

B. UIButton默认可以显示图片

C. 一个APP可以同时显示多个UIWindow

D. UICollectionView继承自UICollectionReusableView

这道题目考察了UIKit框架中各个UI类的继承关系和基本特性。D选项错误,因为UICollectionView实际上是继承自UIScrollView,而不是UICollectionReusableView。UICollectionReusableView是用于实现CollectionView中可重用视图的基类。

### 分析其他选项的正确性:

A正确:UIView是继承自NSObject,这是iOS框架中的基本继承关系。UIView作为所有视图控件的基类,直接继承自NSObject。

B正确:UIButton确实默认支持显示图片,它提供了setImage:forState:方法来设置不同状态下要显示的图片。这是UIButton的基本功能之一。

C正确:一个iOS应用确实可以同时显示多个UIWindow。虽然通常主窗口是最常用的,但在某些场景下(如显示外部显示器内容、创建悬浮窗等)可以创建和显示多个UIWindow。

**核心要点**在于准确理解iOS UI框架的类继承体系,特别是UICollectionView的继承关系,它是一个复杂的滚动视图控件,继承自UIScrollView而不是UICollectionReusableView。

---
## 5. ios哪个版本后，所有的新提交 app 默认是不允许使用 NSAllowsArbitraryLoads 来绕过 ATS 限制的，保证 app 的所有网络请求都是 HTTPS 加密的，否则可能会在应用审核时遇到麻烦

A. ios 8

B. ios 9

C. ios 10

D. ios 11

iOS 10 开始，苹果对 App Transport Security (ATS) 进行了更严格的安全限制，要求所有新提交的应用必须使用 HTTPS 加密通信，不允许通过 NSAllowsArbitraryLoads 来绕过 ATS 的限制。这是为了提高应用的安全性，保护用户数据的传输安全。

### 分析各选项：

A错误：iOS 8 时期还没有引入 ATS 机制，因此不存在相关限制。

B错误：iOS 9 首次引入了 ATS 机制，但当时仍允许开发者通过设置 NSAllowsArbitraryLoads 来允许 HTTP 请求。

C正确：从 iOS 10 开始，苹果收紧了安全策略，新提交的应用必须保证所有网络通信都使用 HTTPS，不再随意允许使用 NSAllowsArbitraryLoads 来绕过 ATS。如果确实需要使用 HTTP，开发者需要在 Info.plist 中提供具体的域名并说明原因。

D错误：iOS 11 相比 iOS 10 在 ATS 方面没有做出重大改变，主要的政策转变发生在 iOS 10。

这个政策变更反映了苹果对应用安全性的重视，HTTPS 的强制要求可以有效防止中间人攻击，保护用户数据传输的安全性。
