## 1. 下面关于集合说法错误的是:

A. OC语言的所有集合都是对象, 集合中的元素也都是对象，集合中也只能存放对象。

B. 集合中不能存放nil空对象，nil是作为集合结束标识符。

C. 简单及复杂数据类型（int、double、CGPoint、CGRect）可以封装为NSValue、NSNumber对象再放入集合类中；

D. OC语言的集合仅包含数组和字典。

**正确答案：D**

### 官方解析：

D选项错误,因为OC语言的集合类型不仅包含数组(NSArray)和字典(NSDictionary),还包括:
*   NSSet(集合)
*   NSOrderedSet(有序集合)
*   NSHashTable
*   NSMapTable 等多种集合类型

分析其他选项:

A选项正确:在OC中,集合确实都是对象(NSArray、NSDictionary等),并且集合中只能存储对象类型,不能直接存储基本数据类型。

B选项正确:nil在OC中是作为集合的结束标识符,集合中不能存储nil对象。如果需要表示空,可以使用NSNull对象。

C选项正确:对于基本数据类型(int、double等)和结构体类型(CGPoint、CGRect等),需要先将其封装成NSNumber或NSValue对象,才能存入集合中。这是因为OC的集合只能存储对象。

**知识延伸:** OC的集合类型丰富,每种集合都有其特定的使用场景。了解这些集合类型的特点和适用场景,对于开发高效的OC程序很重要。


---
## 2. 在Objective-C中，关于Block描述错误的是（）

A. 使用^符号声明Block：在Block的开始位置使用^符号，后面跟着参数列表和代码块

B. 使用typedef定义Block类型

C. Block的语法类似于匿名函数或闭包，它由一对小括号()包围，可以接受参数并返回值

D. Block在Objective-C中广泛应用于异步编程、回调函数、遍历集合等场景

**正确答案：C**

### 官方解析：

C选项错误。Block的语法类似于匿名函数或闭包，它由一对花括号`{}`包围，而不是小括号`()`。小括号`()`通常用于参数列表。

分析其他选项:

A选项正确: 在Block的开始位置使用`^`符号是声明Block的正确方式。

B选项正确: 可以使用`typedef`关键字来定义Block类型，这有助于提高代码的可读性和复用性。

D选项正确: Block在Objective-C中确实广泛应用于异步编程、回调函数、遍历集合以及动画等多种场景，是实现高阶函数和闭包的重要特性。

---
## 3. 下列NSArray初始化不正确的是

A. NSArray *array = [NSArray arrayWithObjects:@"a", @"b", @"c", nil];

B. NSArray *array = [[NSArray alloc] initWithObjects:@"a", @"b", @"c", nil];

C. NSArray *array = @[@"a", @"b", @"c", nil];

D. NSArray *array = @[@"a", @"b", @"c"];

这道题目考察了NSArray的初始化方法。

### 分析所有选项:

A. `NSArray *array = [NSArray arrayWithObjects:@"a", @"b", @"c", nil];`
   **正确**：这是传统的初始化方法，`nil`作为参数列表的结束标志。

B. `NSArray *array = [[NSArray alloc] initWithObjects:@"a", @"b", @"c", nil];`
   **正确**：这也是传统的初始化方法，`nil`作为参数列表的结束标志。

C. `NSArray *array = @[@"a", @"b", @"c", nil];`
   **不正确**：在使用Objective-C字面量语法`@[]`创建数组时，不能包含`nil`。`nil`会被视为数组的结束符，导致`nil`及其后面的元素不会被添加到数组中，这可能导致运行时错误或意外行为。

D. `NSArray *array = @[@"a", @"b", @"c"];`
   **正确**：这是现代Objective-C字面量语法创建数组的正确方式，简洁且推荐使用。

**正确答案：C**

**补充说明:** 在使用字面量语法时，如果需要表示空值，应该使用`NSNull`对象，而不是`nil`。字面量语法是在LLVM 4.0编译器引入的现代Objective-C特性，提供了更简洁的数组创建方式。

---
## 4. 以下关于UIKit说法错误的是：

A. UIView继承自NSObect

B. UIButton默认可以显示图片

C. 一个APP可以同时显示多个UIWindow

D. UICollectionView继承自UICollectionReusableView

这道题目考察了UIKit框架中各个UI类的继承关系和基本特性。D选项错误,因为UICollectionView实际上是继承自UIScrollView,而不是UICollectionReusableView。UICollectionReusableView是用于实现CollectionView中可重用视图的基类。

### 分析其他选项的正确性:

A正确:UIView是继承自NSObject,这是iOS框架中的基本继承关系。UIView作为所有视图控件的基类,直接继承自NSObject。

B正确:UIButton确实默认支持显示图片,它提供了setImage:forState:方法来设置不同状态下要显示的图片。这是UIButton的基本功能之一。

C正确:一个iOS应用确实可以同时显示多个UIWindow。虽然通常主窗口是最常用的,但在某些场景下(如显示外部显示器内容、创建悬浮窗等)可以创建和显示多个UIWindow。

**核心要点**在于准确理解iOS UI框架的类继承体系,特别是UICollectionView的继承关系,它是一个复杂的滚动视图控件,继承自UIScrollView而不是UICollectionReusableView。

---
## 5. ios哪个版本后，所有的新提交 app 默认是不允许使用 NSAllowsArbitraryLoads 来绕过 ATS 限制的，保证 app 的所有网络请求都是 HTTPS 加密的，否则可能会在应用审核时遇到麻烦

A. ios 8

B. ios 9

C. ios 10

D. ios 11

iOS 10 开始，苹果对 App Transport Security (ATS) 进行了更严格的安全限制，要求所有新提交的应用必须使用 HTTPS 加密通信，不允许通过 NSAllowsArbitraryLoads 来绕过 ATS 的限制。这是为了提高应用的安全性，保护用户数据的传输安全。

### 分析各选项：

A错误：iOS 8 时期还没有引入 ATS 机制，因此不存在相关限制。

B错误：iOS 9 首次引入了 ATS 机制，但当时仍允许开发者通过设置 NSAllowsArbitraryLoads 来允许 HTTP 请求。

C正确：从 iOS 10 开始，苹果收紧了安全策略，新提交的应用必须保证所有网络通信都使用 HTTPS，不再随意允许使用 NSAllowsArbitraryLoads 来绕过 ATS。如果确实需要使用 HTTP，开发者需要在 Info.plist 中提供具体的域名并说明原因。

D错误：iOS 11 相比 iOS 10 在 ATS 方面没有做出重大改变，主要的政策转变发生在 iOS 10。

这个政策变更反映了苹果对应用安全性的重视，HTTPS 的强制要求可以有效防止中间人攻击，保护用户数据传输的安全性。

---

## 6. 关于多线程的理解，有误的是  
A、NSOperation是抽象的，不能够直接使用这个类，而是使用子类（ NSInvocationOperation或NSBlockOperation ）来执行实际任务

B、NSOperation（含子类），只是一个操作，本身无主线程、子线程之分，可在任意线程中使用。通常与NSOperationQueue结合使用

C、NSOperation类，在MVC中属于C，是用来封装单个任务相关的代码和数据的抽象类

D、NSOperation本身和多线程没有任何关系，它只是封装了一定的代码段和数据去实现一个功能

正确答案：C

官方解析：
NSOperation是iOS开发中重要的多线程编程工具。C选项有误,因为NSOperation在iOS架构中属于Foundation框架的一部分,而不是MVC模式中的Controller层。

分析其他选项:

A选项正确:NSOperation确实是一个抽象类,不能直接实例化使用。开发中需要使用其具体子类NSInvocationOperation或NSBlockOperation来执行任务。

B选项正确:NSOperation本身只是一个操作对象,它可以在任意线程中执行。通常会配合NSOperationQueue使用来实现多线程操作,但Operation本身与具体线程无关。

D选项正确:NSOperation的核心功能是封装一段要执行的代码和相关数据。它本身不直接处理线程,而是通过与NSOperationQueue配合来实现多线程。

总的来说,NSOperation是Foundation框架提供的用于执行任务的抽象类,常用于多线程编程场景,但其本质是对任务的封装,需要配合队列来实现并发。理解其在iOS框架中的定位很重要。

---

## 7. 关于OC中的block理解正确的有（）

A、是个OC对象

B、内部封装了函数和函数调用环境

C、里面有isa指针

D、捕获了局部变量的block内存在堆上

正确答案：ABCD

官方解析：
block的本质是一个OC对象，编译成C++代码后，是个结构体，里面有isa指针，封装了函数调用环境和函数，block有3种类型，全局block,stack block,堆block,当block没有捕获任何变量的时候是全局block,block捕获了局部变量是堆block

---

## 8. 下面关于Objective-C内存管理说法错误的是（）

A. Objective-C还提供了自动释放池（Autorelease Pool）来管理临时对象的释放

B. 使用了ARC，就不需要注意循环引用（Retain Cycle）的问题了

C. Objective-C内存管理主要使用引用计数（Reference Counting）和分代回收（Generational Collection）来管理对象的内存

D. 在ARC中，可以使用strong、weak、unsafe_unretained等修饰符来声明对象的引用关系

**正确答案：B、C**

### 官方解析：

本题旨在考察Objective-C内存管理的核心概念。其中B和C选项的说法是错误的。

**分析各选项：**

A. **Objective-C还提供了自动释放池（Autorelease Pool）来管理临时对象的释放**
   **正确**：自动释放池是Objective-C中一种重要的内存管理机制，用于管理那些在当前作用域结束时才需要释放的对象（autoreleased objects）。

B. **使用了ARC，就不需要注意循环引用（Retain Cycle）的问题了**
   **错误**：尽管ARC（Automatic Reference Counting）自动管理对象的引用计数，但它无法自动解决循环引用问题。当两个或多个对象之间相互持有对方的强引用时，就会形成循环引用，导致这些对象无法被释放，从而造成内存泄漏。开发者仍然需要通过使用`weak`或`unowned`引用来手动打破循环引用。

C. **Objective-C内存管理主要使用引用计数（Reference Counting）和分代回收（Generational Collection）来管理对象的内存**
   **错误**：Objective-C的内存管理核心机制是**引用计数（Reference Counting）**。它不使用**分代回收（Generational Collection）**。分代回收是某些垃圾回收（Garbage Collection）系统（如Java、.NET）中采用的策略，通过将对象分为不同的“代”来优化回收效率。Objective-C的内存管理模型与垃圾回收机制不同。

D. **在ARC中，可以使用strong、weak、unsafe_unretained等修饰符来声明对象的引用关系**
   **正确**：ARC引入了这些所有权修饰符，用于明确对象之间的引用关系：
   *   `strong`：表示强引用，持有对象并增加其引用计数。
   *   `weak`：表示弱引用，不增加引用计数，当对象被释放时，弱引用会自动置为`nil`。主要用于打破循环引用。
   *   `unsafe_unretained`：表示不安全的弱引用，不增加引用计数，但当对象被释放时，不安全的弱引用不会自动置为`nil`，可能导致野指针问题。通常不推荐使用，除非在特定且明确的场景下。

**总结：** Objective-C的内存管理基于引用计数，ARC简化了手动管理，但循环引用仍需手动处理。分代回收不是Objective-C内存管理的一部分。

---

## 9. 下列哪种类型的属性对象可以使用weak修饰？（）

A、BOOL

B、NSInteger *

C、float *

D、NSString *

正确答案：D
官方解析：
weak修饰符用于解决循环引用问题,只能修饰对象类型的属性,不能修饰基本数据类型。NSString是对象类型,因此可以使用weak修饰,所以D是正确答案。

分析其他选项:

A错误:BOOL是基本数据类型,不是对象类型,不能使用weak修饰。weak只能修饰对象类型的属性。

B错误:NSInteger *虽然是指针类型,但NSInteger本身是基本数据类型(typedef long NSInteger),不是对象,所以不能用weak修饰。

C错误:float *也是指针类型,但float是基本数据类型,不是对象,因此同样不能使用weak修饰。

补充说明:
- weak修饰的属性在对象销毁后会自动置为nil,避免野指针
- weak常用于delegate属性和UI元素的引用,以防止循环引用
- 能用weak修饰的类型必须是Objective-C对象,例如NSArray、UIView等
- weak不会增加引用计数
